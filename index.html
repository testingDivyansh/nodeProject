<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Hello World</h1>
</body>
</html>


<!-- 
Experiment 1 
1 
Ls -l 
2. 
mkdir lab_files 
cd lab_files 
touch example.txt 
3. 
cp example.txt example_backup.txt 
4. 
cd lab_files 
rm example.txt 
5. 
cd lab_files 
mkdir folder1 folder2 folder3 
6. 
The /etc directory in the Linux file system serves a crucial role as it stores configuration files and 
system-wide settings for the operating system and installed applications 
7 
The /usr directory in Linux typically contains user-related programs, libraries, documentation, and 
other files not required for system booting or repair. Here's a list of common directories and files 
found in the /usr directory: 
bin: Contains user executable binaries (programs). 
lib: Libraries required for binaries in /usr/bin and /usr/sbin. 
local: Typically contains locally installed software and libraries managed by the system 
administrator. 
sbin: Contains system administrator binaries (programs). 
share: Architecture-independent data files shared among different architectures. 
include: Header files required for compiling applications. 
src: Source code of various software packages. 
8. 
The /bin and /sbin directories contain essential executable binaries (programs) in the Linux file 
system. Here's an explanation of their significance: 
/bin directory: 
This directory contains essential user-level binaries (programs) that are required for normal 
system operation and are accessible to all users. 
These binaries are fundamental to the system's functioning and are often used during the boot 
process or by regular users for everyday tasks. 
Common binaries found in /bin include basic system utilities like ls (list directory contents), cp 
(copy files), mv (move files), rm (remove files), mkdir (make directories), cat (concatenate and display 
files), and many others. 
Since /bin binaries are essential for the system's operation, they are typically located in a 
directory that is included in the system's default executable search path, allowing users to execute 
them without specifying their full path. 
/sbin directory: 
This directory contains system administration binaries (programs) that are essential for system 
administration tasks and are typically restricted to use by the root user or other privileged users. 
The binaries in /sbin are used for system maintenance, configuration, and troubleshooting 
purposes. 
Common binaries found in /sbin include administrative utilities like mount (mount filesystems), 
umount (unmount filesystems), ifconfig (configure network interfaces), fdisk (disk partitioning), 
shutdown (shutdown or reboot the system), and others. 
By placing these binaries in /sbin, Linux ensures that only users with administrative privileges 
can access and execute them, helping to prevent accidental misuse or unauthorized changes to 
critical system settings. 
Experiment 2 
1. 
#!/bin/bash 
# Prompt the user to enter a value 
echo "Enter a number:" 
read num 
# Initialize sum 
sum=0 
# Loop from 1 to the user-provided value and calculate the sum 
for (( i=1; i<=$num; i++ )) 
do 
sum=$((sum + i)) 
done 
# Print the sum 
echo "The sum of numbers from 1 to $num is: $sum" 
2. 
#!/bin/bash 
# Prompt the user to enter the number of terms 
echo "Enter the number of Fibonacci terms:" 
read num_terms 
# Initialize the first two terms of the Fibonacci series 
a=0 
b=1 
# Print the first two terms 
echo "Fibonacci series up to $num_terms terms:" 
echo -n "$a $b " 
# Loop to generate the remaining terms 
for (( i=3; i<=num_terms; i++ )) 
do 
# Calculate the next term 
next=$((a + b)) 
# Print the next term 
echo -n "$next " 
# Update variables for the next iteration 
a=$b 
b=$next 
done 
echo "" # Print a newline at the end 
3. 
#!/bin/bash 
# Function to check if a number is prime 
is_prime() { 
n=$1 
if [ $n -le 1 ]; then 
echo "$n is not prime." 
exit 1 
fi 
# Loop to check divisibility 
for (( i=2; i*i<=n; i++ )) 
do 
if [ $((n % i)) -eq 0 ]; then 
echo "$n is not prime." 
exit 0 
fi 
done 
echo "$n is prime." 
} 
# Prompt the user to enter a number 
echo "Enter a number:" 
read num 
# Call the is_prime function with the user-input number 
is_prime $num 
4. 
#!/bin/bash 
# Function to reverse a number 
reverse_number() { 
num=$1 
reversed=0 
while [ $num -gt 0 ] 
do 
# Extract the last digit of the number 
digit=$((num % 10)) 
# Append the digit to the reversed number 
reversed=$((reversed * 10 + digit)) 
# Remove the last digit from the number 
num=$((num / 10)) 
done 
echo "Reversed number: $reversed" 
} 
# Prompt the user to enter a number 
echo "Enter a number:" 
read input_number 
# Call the reverse_number function with the user-input number 
reverse_number $input_number 
5. 
#!/bin/bash 
# Prompt the user to enter the directory path 
echo "Enter the directory path:" 
read directory 
# Check if the directory exists 
if [ ! -d "$directory" ]; then 
echo "Error: Directory not found." 
exit 1 
fi 
# Change to the specified directory 
cd "$directory" 
# Display all files in the directory using a for loop 
echo "Files in the directory:" 
for file in * 
do 
# Check if the item is a file 
if [ -f "$file" ]; then 
echo "$file" 
fi 
done 
6. 
#!/bin/bash 
# Define correct username and password 
correct_username="user" 
correct_password="password" 
# Prompt the user to enter a username 
echo "Enter username:" 
read username 
# Prompt the user to enter a password 
echo "Enter password:" 
read -s password # '-s' option hides the password as it's typed 
# Check if both username and password are correct 
if [ "$username" = "$correct_username" ] && [ "$password" = "$correct_password" ]; then 
echo "Access granted." 
else 
echo "Access denied." 
fi 
7 
#!/bin/bash 
# Function to perform addition 
addition() { 
result=$(echo "$1 + $2" | bc) 
echo "Result: $result" 
} 
# Function to perform subtraction 
subtraction() { 
result=$(echo "$1 - $2" | bc) 
echo "Result: $result" 
} 
# Function to perform multiplication 
multiplication() { 
result=$(echo "$1 * $2" | bc) 
echo "Result: $result" 
} 
# Function to perform division 
division() { 
if [ $2 -eq 0 ]; then 
echo "Error: Division by zero is not allowed." 
else 
result=$(echo "scale=2; $1 / $2" | bc) 
echo "Result: $result" 
fi 
} 
# Menu 
echo "Menu:" 
echo "1. Addition" 
echo "2. Subtraction" 
echo "3. Multiplication" 
echo "4. Division" 
echo "5. Exit" 
# Prompt user for choice 
read -p "Enter your choice (1-5): " choice 
# Perform action based on user choice 
case $choice in 
1) read -p "Enter first number: " num1 
read -p "Enter second number: " num2 
addition $num1 $num2 
;; 
2) read -p "Enter first number: " num1 
read -p "Enter second number: " num2 
subtraction $num1 $num2 
;; 
3) read -p "Enter first number: " num1 
read -p "Enter second number: " num2 
multiplication $num1 $num2 
;; 
4) read -p "Enter first number: " num1 
read -p "Enter second number: " num2 
division $num1 $num2 
;; 
5) echo "Exiting..." 
exit 0 
;; 
*) echo "Invalid choice. Please enter a number from 1 to 5." 
esac

Experiment 3 
1. 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/types.h> 
#include<sys/stat.h> 
int main(void){ 
int rfd=open("File.txt",O_RDONLY); 
int wfd=open("test.txt",O_CREAT| O_RDWR,0777); 
if(rfd==-1 || wfd==-1){ 
printf("Error in opening file\n"); 
exit(1); 
} 
off_t fileSize =lseek(rfd,0,SEEK_END); 
lseek(rfd,0,SEEK_SET); 
char buffer[fileSize/2]; 
ssize_t bytesRead=0; 
int n; 
printf("Select the option:\n"); 
printf("1. Copy the first half of data from file.\n"); 
printf("2. Copy the second half of data from file.\n"); 
scanf("%d",&n); 
switch(n){ 
case 1: 
lseek(wfd,0,SEEK_SET); 
bytesRead=read(rfd,buffer,fileSize/2); 
write(wfd,buffer,fileSize/2); 
break; 
case 2: 
lseek(wfd,0,SEEK_SET); 
lseek(rfd,fileSize/2,SEEK_SET); 
bytesRead=read(rfd,buffer,fileSize/2); 
write(wfd,buffer,bytesRead); 
break; 
default: 
printf("Invalid option\n"); 
exit(1); 
} 
close(wfd); 
return 0; 
} 
2. 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/types.h> 
#include<sys/stat.h> 
int main(){ 
int fd=open("input.txt",O_CREAT|O_RDWR,0777); 
off_t fileSize=lseek(fd,0,SEEK_END); 
char buffer[1024]; 
ssize_t totalbytesRead=0; 
char ch; 
while(totalbytesRead<sizeof(buffer)-1){ 
ssize_t bytesRead=read(0,&ch,1); 
if(ch=='$'){ 
break; 
} 
buffer[totalbytesRead++]=ch; 
} 
buffer[totalbytesRead]='\0'; 
write(fd,buffer,totalbytesRead); 
close(fd); 
return 0; 
} 
3. 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/types.h> 
#include<sys/stat.h> 
void encrypt(char buffer[],int shift,int bytesRead){ 
for(int i=0;i<=bytesRead;i++){ 
if(buffer[i]>='a' && buffer[i]<='z'){ 
buffer[i]=((buffer[i]-'a')+shift)%26+'a'; 
} 
else if(buffer[i]>='A' && buffer[i]<='Z'){ 
buffer[i]=((buffer[i]-'A')+shift)%26+'A'; 
} 
} 
} 
int main(){ 
int wfd=open("encrypt.txt",O_CREAT| O_RDWR,0666); 
int rfd=open("file2.txt",O_CREAT| O_RDONLY); 
if(rfd==-1 || wfd==-1){ 
printf("Error while opening file\n"); 
exit(1); 
} 
off_t fileSize=lseek(rfd,0,SEEK_END); 
lseek(rfd,0,SEEK_SET); 
char buffer[fileSize]; 
ssize_t bytesRead=read(rfd,buffer,fileSize); 
int shift; 
printf("Enter the shift value: "); 
scanf("%d",&shift); 
encrypt(buffer,shift,fileSize); 
write(wfd,buffer,bytesRead); 
close(wfd); 
close(rfd); 
return 0; 
} 
Experiment 4 
1. #include <stdio.h> 
#include <stdlib.h> 
#include <sys/stat.h> 
#include <sys/types.h> 
int main() { 
char dirname[100]; 
// Prompt the user to enter the directory name 
printf("Enter the directory name: "); 
scanf("%s", dirname); 
// Create the directory using mkdir system call 
if (mkdir(dirname, 0777) == -1) { 
perror("Error creating directory"); 
exit(EXIT_FAILURE); 
} 
printf("Directory '%s' created successfully.\n", dirname); 
return 0; 
} 
2. 
#include<stdio.h> 
#include<unistd.h> 
#include<dirent.h> 
int main () 
{ 
printf("Enter the path"); 
char path[100]; 
scanf("%s",path); 
DIR *dir; 
struct dirent *de 
dir=opendir(path); 
if(dir) 
{ 
printf("the contents are \n"); 
while(de=readdir(dir)) 
{ 
printf("%s\n",de->d_name); 
} 
closedir(dir); 
} 
return 0; 
} 
3. 
#include <stdio.h> 
#include <stdlib.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <unistd.h> 
int main() 
{ 
} 
4. 
char dirName[16]; 
int ret = 0; 
printf("Enter directory name: "); 
scanf("%s", dirName); 
ret = rmdir(dirName); 
if (ret == 0) 
printf("Given empty directory removed successfully\n"); 
else 
printf("Unable to remove directory %s\n", dirName); 
return 0; 
#include<unistd.h> 
#include<stdlib.h> 
#include<stdio.h> 
int main() 
{ 
char *buf; 
buf=(char *)malloc(100*sizeof(char)); 
//Malloc is used for dynamic memory allocation and is useful when you don't know the amount of 
//memory needed during compile time 
getcwd(buf,100); 
printf("\n %s \n",buf); 
} 
Experiment 5 
1. 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<sys/wait.h> 
int main() 
{ 
int x,i; 
printf("Enter the number of fork commands:\n"); 
scanf("%d",&i); 
for(x=0;x<i;x++) // loop will run n times 
{ 
if(fork() == 0) 
{ 
printf("[son] pid %d from [parent] pid %d\n",getpid(),getppid()); 
exit(0); 
} 
} 
wait(NULL); 
} 
2. 
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
// Driver code 
int main() 
{ 
int pid, pid1, pid2; 
// variable pid will store the 
// value returned from fork() system call 
pid = fork(); 
// If fork() returns zero then it 
// means it is child process. 
if (pid == 0) { 
// First child needs to be printed 
// later hence this process is made 
// to sleep for 3 seconds. 
sleep(3); 
// This is first child process 
// getpid() gives the process 
// id and getppid() gives the 
// parent id of that process. 
printf("child[1] pid = %d and ppid = %d\n", 
getpid(), getppid()); 
} 
else { 
pid1 = fork(); 
if (pid1 == 0) { 
sleep(2); 
printf("child[2]  pid = %d and ppid = %d\n", 
getpid(), getppid()); 
} 
else { 
pid2 = fork(); 
if (pid2 == 0) { 
// This is third child which is 
// needed to be printed first. 
printf("child[3]  pid = %d and ppid = %d\n", 
getpid(), getppid()); 
} 
// If value returned from fork() 
// in not zero and >0 that means 
// this is parent process. 
else { 
} 
} 
} 
return 0; 
} 
3. 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <unistd.h> 
#include <errno.h> 
#include <sys/types.h> 
#include <sys/wait.h> 
// This is asked to be printed at last 
// hence made to sleep for 3 seconds. 
sleep(3); 
printf("parent pid = %d\n", getpid()); 
#define oops(m) {perror(m); exit(EXIT_FAILURE);} 
int main() { 
pid_t pid1_1, pid1_2, pid1_1_1, pid1_1_2, pid1_2_1, pid1_2_2; 
pid1_1 = fork(); 
if (pid1_1 < 0) { 
oops("Fork Failed!"); 
} 
// child 1.1 
if (pid1_1 == 0) { 
printf("I am the child %d\n", getpid()); 
if (execlp("./iam", "iam", "1.1", NULL) < 0) 
oops("Execlp Failed!"); 
} else { 
// grandchild 1.1.1 
pid1_1_1 = fork(); 
if (pid1_1_1 < 0) { 
oops("Fork Failed!"); 
} 
if (pid1_1_1 == 0) { 
printf("I am the grandchild %d\n", getpid()); 
if (execlp("./iam", "iam", "1.1.1", NULL) < 0) 
oops("Execlp Failed!"); 
} 
//grandchild 1.1.2 
pid1_1_2 = fork(); 
if (pid1_1_2 < 0) { 
oops("Fork Failed!"); 
} 
if (pid1_1_2 == 0) { 
printf("I am the grandchild %d\n", getpid()); 
if (execlp("./iam", "iam", "1.1.2", NULL) < 0) 
oops("Execlp Failed!"); 
} 
} 
pid1_2 = fork(); 
if (pid1_2 < 0) { 
oops("Fork Failed!"); 
} 
// child 1.2 
if (pid1_2 == 0) { 
printf("I am the child %d\n", getpid()); 
if (execlp("./iam", "iam", "1.2", NULL) < 0) 
oops("Execlp Failed!"); 
} else { 
// grandchild 1.2.1 
pid1_2_1 = fork(); 
if (pid1_2_1 < 0) { 
oops("Fork Failed!"); 
} 
if (pid1_2_1 == 0) { 
printf("I am the grandchild %d\n", getpid()); 
if (execlp("./iam", "iam", "1.2.1", NULL) < 0) 
oops("Execlp Failed!"); 
} 
// grandchild 1.2.2 
pid1_2_2 = fork(); 
if (pid1_2_2 < 0) { 
oops("Fork Failed!"); 
} 
if (pid1_2_2 == 0) { 
printf("I am the grandchild %d\n", getpid()); 
if (execlp("./iam", "iam", "1.2.2", NULL) < 0) 
oops("Execlp Failed!"); 
} 
} 
// pid > 0 ==> must be parent 
printf("I am the parent %d\n", getpid()); 
/* parent will wait for the child to complete */ 
if (waitpid(-1, NULL, 0) < 0) 
printf("-1 from wait() with errno = %d\n", errno); 
printf("Child terminated; parent exiting\n"); 
exit(EXIT_SUCCESS); 
} 
Experiment 6 
1. 
#include <stdio.h> 
#include<stdlib.h> 
#include<string.h> 
#include<pthread.h> 
//char str1[100] = "Hi ", str2[100] = "World"; 
char str1[100],str2[100],str3[100]; 
void *concat() 
{ 
strcat(str1,str2); 
strcpy(str3,str1); 
pthread_exit(NULL); 
} 
int main() 
{ 
pthread_t t1; 
printf("Enter the string1:"); 
scanf("%s",str1); 
printf("Enter the string2:"); 
scanf("%s",str2); 
pthread_create(&t1,NULL,concat,NULL); 
pthread_join(t1,NULL); 
printf("%s",str3); 
return 0; 
} 
2. 
#include <stdio.h> 
#include<stdlib.h> 
#include<string.h> 
#include<pthread.h> 
char length1[100]; 
int length=0; 
void *length_str() 
{ 
length=strlen(length1); 
pthread_exit(NULL); 
} 
int main() 
{ 
pthread_t t1; 
printf("Enter the string:"); 
scanf("%s",length1); 
pthread_create(&t1,NULL,length_str,NULL); 
pthread_join(t1,NULL); 
printf("The total length of string is %d\n",length); 
return 0; 
} 
3. 
#include <stdio.h> 
#include<stdlib.h> 
#include<string.h> 
#include<pthread.h> 
int arr[10]={99,22,00,88,11,102,33,36,66,55}; 
void *sort(void *arg) 
{ 
for (int i=0;i<10;i++) 
for (int j=0;j<10;j++) 
if(arr[i]<arr[j]) 
{ 
int temp=arr[i]; 
arr[i]=arr[j]; 
arr[j]=temp; 
} 
pthread_exit(NULL); 
} 
void *min(void *arg) 
{ 
int min=arr[0]; 
printf("Minimum element is %d\n",min); 
pthread_exit(NULL); 
} 
void *max(void *arg) 
{ 
int max=arr[9]; 
printf("Maximum element is %d\n",max); 
pthread_exit(NULL); 
} 
void *avg(void *arg) 
{ 
int sum=0; 
for (int i=0;i<10;i++) 
{ 
sum=sum+arr[i]; 
} 
sum=sum/10; 
printf("Average element is %d\n",sum); 
pthread_exit(NULL); 
} 
int main() 
{ 
printf("Old array:\n"); 
for (int j=0;j<10;j++) 
{ 
printf("%d\n",arr[j]); 
} 
pthread_t sort_thread,max_thread,min_thread,avg_thread; 
pthread_create(&sort_thread,NULL,sort,NULL); 
pthread_join(sort_thread,NULL); 
pthread_create(&max_thread,NULL,max,NULL); 
pthread_join(max_thread,NULL); 
pthread_create(&min_thread,NULL,min,NULL); 
pthread_join(min_thread,NULL); 
pthread_create(&avg_thread,NULL,avg,NULL); 
pthread_join(avg_thread,NULL); 
return 0; 
} 
4. 
#include <stdio.h> 
#include <stdlib.h> 
#include <pthread.h> 
#define ARRAY_SIZE 10 
// Structure to pass arguments to the threads 
typedef struct { 
int* array; 
int start; 
int end; 
} ThreadArgs; 
// Function to merge and sort two sorted arrays 
void merge(int* arr, int start, int mid, int end) { 
int i = start; 
int j = mid + 1; 
int k = 0; 
int temp[end - start + 1]; 
while (i <= mid && j <= end) { 
if (arr[i] <= arr[j]) { 
temp[k++] = arr[i++]; 
} else { 
temp[k++] = arr[j++]; 
} 
} 
while (i <= mid) { 
temp[k++] = arr[i++]; 
} 
while (j <= end) { 
temp[k++] = arr[j++]; 
} 
for (i = start; i <= end; i++) { 
arr[i] = temp[i - start]; 
} 
} 
// Function to sort a portion of the array 
void* sort(void* arg) { 
ThreadArgs* args = (ThreadArgs*)arg; 
int* array = args->array; 
int start = args->start; 
int end = args->end; 
// Sorting the portion of the array 
for (int i = start; i <= end; i++) { 
for (int j = i + 1; j <= end; j++) { 
if (array[i] > array[j]) { 
int temp = array[i]; 
array[i] = array[j]; 
array[j] = temp; 
} 
} 
} 
pthread_exit(NULL); 
} 
// Function to create and join threads for sorting 
void createAndJoinThreads(pthread_t* threads, ThreadArgs* args, int num_threads) { 
for (int i = 0; i < num_threads; i++) { 
pthread_create(&threads[i], NULL, sort, (void*)&args[i]); 
} 
for (int i = 0; i < num_threads; i++) { 
pthread_join(threads[i], NULL); 
} 
} 
int main() { 
int array[ARRAY_SIZE] = {9, 5, 2, 7, 1, 8, 4, 3, 6, 0}; 
pthread_t threads[3]; 
ThreadArgs args[2]; 
// Divide the array into two halves 
int mid = ARRAY_SIZE / 2; 
// Thread arguments for the first half of the array 
args[0].array = array; 
args[0].start = 0; 
args[0].end = mid - 1; 
// Thread arguments for the second half of the array 
args[1].array = array; 
args[1].start = mid; 
args[1].end = ARRAY_SIZE - 1; 
// Create and join threads for sorting each half of the array 
createAndJoinThreads(threads, args, 2); 
// Merge and sort the two sorted halves 
merge(array, 0, mid - 1, ARRAY_SIZE - 1); 
// Print the sorted array 
printf("Sorted array:\n"); 
for (int i = 0; i < ARRAY_SIZE; i++) { 
printf("%d ", array[i]); 
} 
printf("\n"); 
return 0; 
} 
5. 
#include <stdio.h> 
#include <stdlib.h> 
#include <pthread.h> 
#define NUM_THREADS 5 
// Structure to pass arguments to the thread functions 
typedef struct { 
int thread_id; 
} ThreadArgs; 
// Function executed by each thread 
void *thread_function(void *args) { 
ThreadArgs *thread_args = (ThreadArgs *)args; 
int thread_id = thread_args->thread_id; 
printf("Thread %d: Executing\n", thread_id); 
pthread_exit(NULL); 
} 
int main() { 
pthread_t threads[NUM_THREADS]; 
ThreadArgs thread_args[NUM_THREADS]; 
// Creating multiple threads 
for (int i = 0; i < NUM_THREADS; i++) { 
thread_args[i].thread_id = i + 1; // IDs start from 1 
if (pthread_create(&threads[i], NULL, thread_function, (void *)&thread_args[i]) != 0) { 
perror("pthread_create"); 
exit(EXIT_FAILURE); 
} 
} 
// Waiting for all threads to finish 
for (int i = 0; i < NUM_THREADS; i++) { 
if (pthread_join(threads[i], NULL) != 0) { 
perror("pthread_join"); 
exit(EXIT_FAILURE); 
} 
} 
printf("All threads have finished execution.\n"); 
return 0; 
} 
6. 
#include <stdio.h> 
#include <stdlib.h> 
#include <pthread.h> 
#include <unistd.h> // for sleep() 
#define NUM_THREADS 2 
// Global variable to indicate if the thread should continue running 
int keep_running = 1; 
// Thread function demonstrating graceful termination 
void *graceful_thread_function(void *arg) { 
int thread_id = *((int *)arg); 
printf("Graceful Thread %d: Started\n", thread_id); 
// Loop until instructed to stop 
while (keep_running) { 
printf("Graceful Thread %d: Running\n", thread_id); 
sleep(1); 
} 
printf("Graceful Thread %d: Cleanup\n", thread_id); 
// Cleanup resources 
// Simulating cleanup by printing a message 
printf("Graceful Thread %d: Exiting\n", thread_id); 
pthread_exit(NULL); 
} 
// Thread function demonstrating abrupt termination 
void *abrupt_thread_function(void *arg) { 
int thread_id = *((int *)arg); 
printf("Abrupt Thread %d: Started\n", thread_id); 
// Loop indefinitely without cleanup 
while (1) { 
printf("Abrupt Thread %d: Running\n", thread_id); 
sleep(1); 
} 
// Cleanup code will never be reached 
pthread_exit(NULL); 
} 
int main() { 
pthread_t threads[NUM_THREADS]; 
int thread_ids[NUM_THREADS]; 
// Create threads for graceful termination 
for (int i = 0; i < NUM_THREADS; ++i) { 
thread_ids[i] = i + 1; 
if (pthread_create(&threads[i], NULL, graceful_thread_function, &thread_ids[i]) != 0) { 
perror("pthread_create"); 
exit(EXIT_FAILURE); 
} 
} 
// Wait for some time before terminating the threads gracefully 
sleep(5); 
// Set the flag to stop the threads 
keep_running = 0; 
// Join the threads to wait for their termination 
for (int i = 0; i < NUM_THREADS; ++i) { 
if (pthread_join(threads[i], NULL) != 0) { 
perror("pthread_join"); 
exit(EXIT_FAILURE); 
} 
} 
printf("Graceful thread termination complete.\n"); 
// Create threads for abrupt termination 
for (int i = 0; i < NUM_THREADS; ++i) { 
thread_ids[i] = i + 1; 
if (pthread_create(&threads[i], NULL, abrupt_thread_function, &thread_ids[i]) != 0) { 
perror("pthread_create"); 
exit(EXIT_FAILURE); 
} 
} 
// Wait for some time before abruptly terminating the threads 
sleep(5); 
// Cancel the threads abruptly 
for (int i = 0; i < NUM_THREADS; ++i) { 
if (pthread_cancel(threads[i]) != 0) { 
perror("pthread_cancel"); 
exit(EXIT_FAILURE); 
} 
} 
printf("Abrupt thread termination complete.\n"); 
return 0; 
} -->


<!--

# Practical-2 (Shell Programming) 


Q1. Write a shell script to write "Multiplication Tables" 


 Code: 

#! /usr/bin/bash

echo "Enter a Number: "
read a

for((i=0; i<a; i++))
do
	b=$((a*i))
	echo "$a x $i = $b"
done


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _



Q2. Write a shell script for a "Small Calculator" 


 Code:

#! /usr/bin/bash

echo "Enter 1st Number: "
read a 

echo "Enter 2nd Number: "
read b 

echo "Which operation do you wanna perform"
echo "1. Addition      2. Subtraction        3. Multiplication       4. Division        5. Exit Calculator Interface"
read c

if [ $c -eq 1 ]
then
	let d=$a+$b
	echo "Sum of these two numbers is: $d"
fi

if [ $c -eq 2 ]
then
	echo " "
	echo "Do you wanna Subtract: "
	echo "1. 1st no. from 2nd no."
	echo "OR"
	echo "2. 2nd no. from 1st no."
	echo "Enter 1 or 2 as per your need."
	read e
	
	if [ $e -eq 1 ]
	then
		let d=$b-$a
		echo " "
		echo "When you subtract 1st no. from 2nd no. you get: $d"
	
	elif [ $e -eq 2 ]
	then
		let d=$a-$b
		echo " "
		echo "When you subtract 2nd no. from 1st no. you get: $d"
	fi
fi

if [ $c -eq 3 ]
then
	let d=$a*$b
	echo "Multiplication of these two numbers is: $d"
fi

if [ $c -eq 4 ]
then
	echo " "
	echo "Do you wanna Divide: "
	echo "1. 1st no. by 2nd no."
	echo "OR"
	echo "2. 2nd no. by 1st no."
	echo "Enter 1 or 2 number as per your need."
	read e
	
	if [ $e -eq 1 ]
	then
		echo " "
		echo "When you divide 1st no. by 2nd no. you get: " 
		echo "scale=2; $a/$b" | bc
	
	elif [ $e -eq 2 ]
	then
		echo " "
		echo "When you divide 2nd no. by 1st no. you get: "
		echo "scale=2; $b/$a" | bc
	fi
fi


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	
	

Q3. Write a shell script for "Diplaying prime numbers upto a given limit" 


 Code: 

#! /usr/bin/bash

echo "Enter a Number: " 
read a

for ((i=2; i<=a; i++))
do
	n=0
	for ((j=2; j<i; j++))
	do
		let b=$i%$j
		if [ $b -eq 0 ]
		then 
			n=1
		fi
	done
	
	if [ $n -eq 0 ]
	then
		echo $i
	fi
done 	


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 



# Practical-3 (File Manipulation Using System Calls) 


Q1. Using system calls copy first half of the content of a already existing file to a newly created file and then again copy the rest remaining second half of the content of that older file to a another newly created file 


 Code: 

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(){
	int a, b, c, n;
	char buff1[500];
	
	a = open("content.txt", O_RDONLY | O_CREAT, 0777);
	b = open("FirstHalf.txt", O_WRONLY | O_CREAT, 0777);
	c = open("SecondHalf.txt", O_WRONLY | O_CREAT, 0777);
	
	n = read(a, buff1, 500);
	
	read(a, buff1, n/2);
	write(b, buff1, n/2);
	
	lseek(a, n/2, SEEK_SET);
	read(a, buff1, n/2);
	write(c, buff1, n/2);
	
	return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	
	

Q2. Using system calls write a program which reads from console until user types '$' and the content which is written on the console before '$' copy that content to a newly created file 


 Code: 

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(){
	int a, b=0;
	char buff1[500];
	scanf("%[^\n]s", buff1);
	
	a = open("Output$.txt", O_WRONLY | O_CREAT, 0777);
	
	for(int i=0; i<500; i++){
		if(buff1[i] == '$'){
			printf("You can not write after '$' Symbol \n");
			break;
		}
		
		else{
			b++;
		}
	}
	
	char buff2[b];
	
	for(int i=0; i<b; i++){
		buff2[i]=buff1[i];
	}
	
	write(a, buff2, b);
	return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	


Q3. Write a program using system call to read the contents of a file without using char array and display the contents on the console (Don't use any built in functions like sizeof() and strlen()) 


 Code: 

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(){
	int a, b;
	a = open("Input.txt", O_RDONLY | O_CREAT, 0777);
	char buff[1];
	char *c = buff;
	
	while((b = read(a, c, 1))>0){
		write(1, c, 1);
	}
	
	return 0;
}



_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 



# Practical-4 (Directory Manipulation Using System Calls) 


Q1. Write a program using directory system calls, make a directory on desktop and create a file inside the directory and list the contents of the directory 


 Code: 

#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<dirent.h>

int main()
{
	int a = mkdir("My_Directory",0777);
	if(a!=-1)
	{
		printf("# You're directory has been created: \n");
		printf(" \n");
	}

	struct dirent *dptr;
		
	int fd1 = creat("My_Directory/testing_123.txt",0777);
	int fd2 = creat("My_Directory/noicee.txt",0777);
	int fd3 = creat("My_Directory/life_is_good.txt",0777);
	
	if(fd1!=-1 && fd2!=-1 && fd3!=-1)
	{
		printf("* file testing_123.txt is created.\n");
		printf("* noicee.txt is created.\n");
		printf("* life_is_good.txt is created.\n");
		printf(" \n");
	}
	
	DIR *dp = opendir("My_Directory");
	
	printf("@ List of files in created directory: \n");
	
	while(NULL!=(dptr = readdir(dp)))
	{
		printf("%s\n", dptr->d_name);
	}
	return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	


Q2. Write a program using directory and file manipulation system calls to copy the contents of one directory to a newly created directory 


 Code: 

#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<dirent.h>

int main()
{
	struct dirent *dptr;
	
	int a = mkdir("My_Directory", 0777);
	int b = mkdir("Your_Directory", 0777);
	
	if(a==0 && b==0){
		printf("* Directories named 'My_Directory' and 'Your_Directory' has been created Successfully. \n");
	}
	else{
		printf("* Either directories named 'My_Directory' & 'Your_Directory' already exist or they were not able to create due to any Error. \n");
	}
	
	int fd1 = open("My_Directory/My_File.txt", O_CREAT|O_RDWR, 0777);
	
	printf("* File named 'My_File.txt' has been created Successfully in Directory named 'My_Directory'. \n");
	printf(" \n");
	
	char c[1000];
	
	printf("# Kuch to likh de yaar file me, copy karani hai file: \n");
	scanf("%[^\n]s", c);
	printf(" \n");
	
	int size=0;
	
	for(int i=0;i<100;i++)
	{
		if(c[i]=='\0'){
			break;
		}
		
		else{
			size++;
		}
	}
	
	write(fd1, c, size);
	printf("@ Given input text from user has been Successfully copied in file named 'My_File.txt'. \n");
	printf(" \n");
	
	DIR *dp = opendir("Your_Directory");
	
	int no_of_files=-2;
	
	while(NULL != (dptr=readdir(dp)))
	{
		no_of_files++;
	}
	
	printf("# No. of files in directory which is named 'Your_Directory' are: \n");
	printf("%d\n",no_of_files);
	printf(" \n");
	
	int fd2 = open("Your_Directory/My_File_Copy.txt", O_CREAT | O_RDWR, 0777);
	printf("* File named 'My_File_Copy.txt' has been created Successfully in Directory named 'Your_Directory'. \n");
	
	write(fd2, c, size);
	printf("* Content of File named 'My_File' in Directory named 'My_Directory' has been Successfully Copied to file named 'My_File_Copy.txt' which is in Directory named 'Your_Directory' \n");
	printf(" \n");
	
	// -----------------------------------------------------------------------------------------
	
	DIR *dp1 = opendir("Your_Directory");
	
	int new_no_of_files=-2;
	
	while(NULL != (dptr=readdir(dp1)))
	{
		new_no_of_files++;	
	}
	
	printf("# Now no. of files in directory which is named 'Your_Directory' are: \n");
	printf("%d\n", new_no_of_files);
	printf(" \n");
	
	return 0;
}



_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 



# Practical-5 (Process Management Using System Calls) 


Q1. Write a program using system calls for operation on process to stimulate n fork calls to create (2^n - 1) child processes 

 Code: 

#include<stdio.h>              // for printf and scanf
#include<unistd.h>             // for fork() & getpid()
#include<sys/types.h>          // for fork() & getpid()

int main(){
	
	int n;
	
	printf("# Enter the no. of times you want to run the fork system call: ");
	scanf("%d", &n);
	
	for(int i=0; i<n; i++){
		pid_t r;
		r = fork();
		if(r==0){
			printf("Current child process pid is %d \n", getpid());
		}
	}

	return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	



Q2. Write a program using system calls for operations on processes to create a heirarchy of processes P1 -> P2 -> P3, also print the id and parent id for each process 


 Code: 

#include<stdio.h>             //  for printf and scanf 
#include<unistd.h>            //  for fork(), getpid() & getppid() 
#include<sys/types.h>         //  for fork(), getpid() & getppid() 
#include <stdlib.h>           //  for exit() 

int main()
{
	printf("Parent PID : %d \n", (int) getpid());
	
	pid_t pid = fork();
	
	if(pid == 0)
	{
		printf("Child 1 PID : %d Parent PID : %d\n", (int) getpid(), (int) getppid());
		pid_t pid_1 = fork();
		if(pid_1 == 0)
		{
			printf("Child 2 PID : %d Parent PID (Child 1) : %d \n", (int) getpid(), (int) getppid());
			exit(0);
		}
		else
		{
			exit(0);
		}
	}
	else
	{
		exit(0);	
	}
	
	return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	



Q3. Write a program using system calls for operations on processes to create a heirarchy of processes: P3 <- P2 <- P1 -> P4 -> P5, also stimulate process P4 as orphan and P5 as zombie 


 Code: 

#include<stdio.h>               //  for printf and scanf 
#include<unistd.h>              //  for fork(), getpid(), sleep() & getppid() 
#include<sys/types.h>           //  for fork(), getpid() & getppid() 
#include<stdlib.h>              //  for exit() 


// In Orphan Process, child process P4 goes to sleep and whenever the sleep time period is completed and P4 comes back for execution it's parent has already completed it's execution. So, it will get a garbage parent PID, whenever it wants to access it's parents PID as it is a orphan process. 
	
// In Zombie Process, the parent process P4 goes to sleep and the child process P5 executes before P4 and leaves, and then after the completion of sleep time period process P4 executes, so here child process P5 will be called zombie process beacuse it has executed before it's parent's execution, and for P4 (parent) the process P5 is still visible in it's table but it has already completed it's execution. 



int main()
{	
	printf("P1 PID : %d \n", (int) getpid());
	pid_t pid = fork();
	
	if(pid == 0)
	{
		printf("P4 PID : %d P1 PID : %d\n", (int) getpid(), (int) getppid());
		printf("Child process P4 is sleeping \n");
		pid_t pid_1 = fork();
		sleep(5);
		if(pid_1 == 0)
		{
			printf("P5 PID : %d P4 PID : %d \n", (int) getpid(), (int) getppid());
			printf("Zombie process P5's PID : %d \n", (int) getpid());
		}
		else{
			printf("Orphan child process P4's PID : %d \n", (int) getpid());
			printf("P4's New Parent PID : %d \n", (int) getppid());
		}
	}
	else
	{
		pid = fork();
		if(pid == 0)
		{
			printf("P2 PID : %d P1 PID : %d\n", (int) getpid(), (int) getppid());
			pid_t pid_1 = fork();
			if(pid_1 == 0)
			{
				printf("P3 PID : %d P2 PID : %d \n", (int) getpid(), (int) getppid());
				exit(0);
			}
			else
			{
				exit(0);
			}
		}
		else
		{
			exit(0);
		}
	}
	
	return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	


Q4. Write a program using system calls for operations on processes to create a heirarchy of processes: P4 <- P3 <- P2 <- P1 -> P5 -> P6 -> P7, also stimulate process P4 as an orphan process and P7 as zombie process 


 Code: 

#include<stdio.h>               //  for printf and scanf 
#include<unistd.h>              //  for fork(), getpid(), sleep() & getppid() 
#include<sys/types.h>           //  for fork(), getpid() & getppid() 
#include<stdlib.h>              //  for exit() 

int main()
{
	printf("P1 PID : %d \n", (int) getpid());
	
	pid_t pid = fork();
	
	if(pid == 0)
	{
		printf("P5 PID : %d Parent P1 PID : %d\n", (int) getpid(), (int) getppid());
		pid_t pid_1 = fork();
		if(pid_1 == 0)
		{
			printf("P6 PID : %d Parent P5 PID : %d \n", (int) getpid(), (int) getppid());
			
			pid_t pid_2 = fork();
			sleep(5);
			
			if(pid_2 == 0)
			{
				printf("Zombie process P7's PID: %d \n", (int) getpid());
				printf("Parent P6 PID : %d \n", (int) getppid());
			}
			else
			{
				exit(0);
			}
		}
		else
		{
			exit(0);
		}
	}
	
	else
	{
		pid = fork();
		if(pid == 0)
		{
			printf("P2 PID : %d Parent P1 PID : %d\n", (int) getpid(), (int) getppid());
			pid_t pid_1 = fork();
			if(pid_1 == 0)
			{
				printf("P3 PID : %d Parent P2 PID : %d \n", (int) getpid(), (int) getppid());
			
				pid_t pid_2 = fork();
				if(pid_2 == 0)
				{
					sleep(3);
				}
				else
				{
					printf("Orphan child process P4's PID : %d \n", (int) pid_2);
					printf("P4's New Parent PID : %d \n", (int) getppid());
				}
			}
			else
			{
				exit(0);
			}
		}	
	}
	
	return 0;
}



_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 



# Practical-6 (Creation of Multithreaded Processes using Pthread Library)  


Q1. Write a program using pthread to concatenate the strings, where multiple strings are passed to thread function 


 Code:

#include<stdio.h>
#include<unistd.h>
#include<pthread.h>
#include<string.h>


char str1[100], str2[100];
char result[1000];


void *concatenatestrings(){
	strcat(result, str1);
	strcat(result, str2);
	pthread_exit(NULL);
}

int main(){
	pthread_t thread;
	printf("* Enter the first string: ");
	scanf("%s", str1);
	printf("* Enter the second string: ");
	scanf("%s", str2);
	
	pthread_create(&thread, NULL, concatenatestrings, NULL);
	pthread_join(thread, NULL);
	
	printf("@ Final result is: %s \n", result);
	return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	


Q2. Write a program using pthread to find the length of string, where strings are passed to thread function 


 Code:

#include<stdio.h>
#include<unistd.h>
#include<pthread.h>
#include<string.h>

char length1[100];
int length=0;

void *lengthstr(){
	length=strlen(length1);
	pthread_exit(NULL);
}


int main(){
	pthread_t thread;
	printf("* Enter the String: ");
	scanf("%[^\n]s", length1);
	
	pthread_create(&thread, NULL, lengthstr, NULL);
	pthread_join(thread, NULL);
	printf("* Total length of string is: %d \n", length);
	return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	


Q3. Write a program that performs statistical operations of calculating the average, maximum & minimum for a set of numbers. Create three threads where each performs their respective operations.


 Code:

#include<stdio.h>
#include<pthread.h>

int arr[10] = {99, 22, 00, 88, 11, 102, 33, 66, 44, 55};

void *sort(){
	for(int i=0; i<10; i++){
		for(int j=0; j<10; j++){
			if(arr[i] < arr[j]){
				int temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
			}
		}
	}
}


void *min(){
	int min = arr[0];
	printf("* Minimum element is = %d\n", min);
	pthread_exit(NULL);
}


void *max(){
	int max = arr[9];
	printf("* Maximum element is = %d \n", max);
	pthread_exit(NULL);
}


void *avg(){
	int sum=0;
	for(int i=0;i<10;i++)
	{
		sum = sum + arr[i];
	}
	sum = sum/10;
	
	printf("* The average of the elements = %d \n", sum);
	printf("\n");
	pthread_exit(NULL);
}


int main(){

	printf("\n");		
	
	/* 
	printf("Enter 10 elements in the array: ");
	for(int i=0; i<10; i++)
	{
		scanf("%d", &arr[i]);
	}
	printf("\n");
	*/
	
	printf("# Initial input array is: ");
	for(int i=0; i<10; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
	
	
	pthread_t sort_thread, max_thread, min_thread, avg_thread;
	
	pthread_create(&sort_thread, NULL, sort, NULL);
	pthread_join(sort_thread, NULL);
	
	pthread_create(&max_thread, NULL, max, NULL);
	pthread_join(max_thread, NULL);
	
	pthread_create(&min_thread, NULL, min, NULL);
	pthread_join(min_thread, NULL);
	
	pthread_create(&avg_thread, NULL, avg, NULL);
	pthread_join(avg_thread, NULL);
	return 0;
} 


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _	



Q4. Write a multithreaded program where an array of integers is passed globally and is divided into two smaller lits and given as input to two threads. The thread will sort their half of the list and will pass the sorted list to a third thread which merges and sorts the list. The final sorted list is printed by the parent thread. 


 Code:

#include<stdio.h>
#include<pthread.h>

int arr[10] = {99, 22, 00, 88, 11, 100, 33, 66, 44, 55};


int arr_first_half[5], arr_second_half[5], final_arr[10];


void *final_merge_sort(){

	for(int i=0; i<5; i++){
		final_arr[i] = arr_first_half[i];
		final_arr[i+5] = arr_second_half[i];
	}
	
	printf("# Merged array is: ");
	for(int i=0; i<10; i++){
		printf("%d ", final_arr[i]);
	}
	printf("\n");
	
	for(int i=0; i<10; i++){
		for(int j=0; j<10; j++){
			if(final_arr[i] < final_arr[j]){
				int temp = final_arr[i];
				final_arr[i] = final_arr[j];
				final_arr[j] = temp;
			}
		}
	}

	printf("@ Final Merged & Sorted array is: ");
	for(int i=0; i<10; i++){
		printf("%d ", final_arr[i]);
	}
	printf("\n");
	printf("\n");

	pthread_exit(NULL);
}


void *individual_sort(){
	for(int i=0; i<5; i++){
		for(int j=0; j<5; j++){
			if(arr_first_half[i] < arr_first_half[j]){
				int temp = arr_first_half[i];
				arr_first_half[i] = arr_first_half[j];
				arr_first_half[j] = temp;
			}
			if(arr_second_half[i] < arr_second_half[j]){
				int temp = arr_second_half[i];
				arr_second_half[i] = arr_second_half[j];
				arr_second_half[j] = temp;	
			}
		}
	}
		
	pthread_exit(NULL);
}


int main()
{
	printf("\n");		
	
	/* 
	printf("Enter 10 elements in the array: ");
	for(int i=0; i<10; i++)
	{
		scanf("%d", &arr[i]);
	}
	printf("\n");
	*/
		
	printf("# Initial input array is: ");
	for(int i=0; i<10; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");

	
	for(int i=0; i<5; i++){
		arr_first_half[i] = arr[i];
		arr_second_half[i] = arr[i+5];
	}
	
	
	
	pthread_t parent_thread;
	pthread_create(&parent_thread, NULL, individual_sort, NULL);
	pthread_join(parent_thread, NULL);
	
	printf("* First half sorted array is: ");
	for(int i=0; i<5; i++){
		printf("%d ", arr_first_half[i]);
	}
	printf("\n");
	
	
	printf("* Second half sorted array is: ");
	for(int i=0; i<5; i++){
		printf("%d ", arr_second_half[i]);
	}
	printf("\n");
	
	pthread_create(&parent_thread, NULL, final_merge_sort, NULL);
	pthread_join(parent_thread, NULL);
	
	return 0;
} 


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 



# Practical-7th (Process Synchronization Using Semaphores/Mutex): 



* Race Around Condition: 


 Code: 

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

int NUM_THREADS = 2;
int shared = 0;

void *thread_func(void *arg) {
	int id = *(int *) arg;
	int local = 0;

	for (int i = 0; i < 1000000; i++) {
    	local = shared;
    	local++;
    	shared = local;
	}

	printf("Thread %d: shared = %d\n", id, shared);

	pthread_exit(NULL);
}

int main() {
	pthread_t threads[NUM_THREADS];
	int thread_ids[NUM_THREADS];

	for (int i = 0; i < NUM_THREADS; i++) {
    	thread_ids[i] = i;
    	pthread_create(&threads[i], NULL, thread_func, (void *) &thread_ids[i]);
	}

	for (int i = 0; i < NUM_THREADS; i++) {
    	pthread_join(threads[i], NULL);
	}

	printf("Final value of shared = %d\n", shared);

	return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _



* Race Around Condition Solved Using Mutex: 

 Code: 

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

int NUM_THREADS = 2;
int shared = 0;

pthread_mutex_t mutex;

void *thread_func(void *arg) {
    int id = *(int *) arg;
    int local = 0;
    pthread_mutex_lock(&mutex);
    for (int i = 0; i < 1000000; i++) {
   	 local = shared;
   	 local++;
   	 shared = local;
    }
    printf("Thread %d: shared = %d\n", id, shared);
    pthread_mutex_unlock(&mutex);
    pthread_exit(NULL);
}

int main() {
    pthread_t threads[NUM_THREADS];
    int thread_ids[NUM_THREADS];
    pthread_mutex_init(&mutex,NULL);
    for (int i = 0; i < NUM_THREADS; i++) {
   	 thread_ids[i] = i;
   	 pthread_create(&threads[i], NULL, thread_func, (void *) &thread_ids[i]);
    }

    for (int i = 0; i < NUM_THREADS; i++) {
   	 pthread_join(threads[i], NULL);
    }

    printf("Final value of shared = %d\n", shared);

    return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _



* Race Around Condition Solved Using Semaphore: 


 Code: 

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>


int NUM_THREADS = 2;
int shared = 0;

sem_t semaphore;

void *thread_func(void *arg) {
    int id = *(int *) arg;
    int local = 0;
    sem_wait(&semaphore);
    for (int i = 0; i < 1000000; i++) {
   	 local = shared;
   	 local++;
   	 shared = local;
    }
    printf("Thread %d: shared = %d\n", id, shared);
    sem_post(&semaphore);
    pthread_exit(NULL);
}

int main() {
    pthread_t threads[NUM_THREADS];
    int thread_ids[NUM_THREADS];
    sem_init(&semaphore,0,1);
    for (int i = 0; i < NUM_THREADS; i++) {
   	 thread_ids[i] = i;
   	 pthread_create(&threads[i], NULL, thread_func, (void *) &thread_ids[i]);
    }

    for (int i = 0; i < NUM_THREADS; i++) {
   	 pthread_join(threads[i], NULL);
    }

    printf("Final value of shared = %d\n", shared);
    sem_destroy(&semaphore);
    return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _



* Producer & Consumer Using Mutex 


 Code: 

#include <stdio.h> 
#include <stdlib.h> 
#include <pthread.h> 


int BUFFER_SIZE = 5; 
int buffer[5]; 
int count = 0; 
int last_consumed_index = 0; 

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 
pthread_cond_t cond_producer = PTHREAD_COND_INITIALIZER; 
pthread_cond_t cond_consumer = PTHREAD_COND_INITIALIZER; 

void* producer(void* arg) {
    int item;
    int iterations = 0;
    while (iterations < 10) { // exit after 10 iterations
        item = rand() % 100; // generate a random item
        pthread_mutex_lock(&mutex);
        if (count == BUFFER_SIZE) {
            pthread_cond_wait(&cond_producer, &mutex);
        }
        if (count == 0) {
            last_consumed_index = 0; // reset last consumed index if buffer is empty
        }
        buffer[last_consumed_index++] = item;
        printf("Produced item: %d\n", item);
        count++;
        if (count == 1) {
            pthread_cond_signal(&cond_consumer);
        }
        pthread_mutex_unlock(&mutex);
        iterations++;
    }
    return NULL;
}

void* consumer(void* arg) {
    int item;
    int iterations = 0;
    while (iterations < 10) { // exit after 10 iterations
        pthread_mutex_lock(&mutex);
        if (count == 0) {
            pthread_cond_wait(&cond_consumer, &mutex);
        }
        item = buffer[--last_consumed_index];
        printf("Consumed item: %d\n", item);
        count--;
        if (count == BUFFER_SIZE - 1) {
            pthread_cond_signal(&cond_producer);
        }
        pthread_mutex_unlock(&mutex);
        iterations++;
    }
    return NULL;
}

int main() {
    pthread_t producer_thread, consumer_thread;
    srand(time(NULL)); // initialize the random seed

    pthread_create(&producer_thread, NULL, producer, NULL);
    pthread_create(&consumer_thread, NULL, consumer, NULL);

    pthread_join(producer_thread, NULL);
    pthread_join(consumer_thread, NULL);

    return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _




* Reader Writer Problem using Semaphore: 


 Code: 

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

int NUM_READERS = 3;
int NUM_WRITERS = 2;
int MAX_ATTEMPTS = 5;

// Shared data
int shared_data = 0;
int num_readers = 0;

// Semaphores
sem_t mutex;
sem_t wrt;

// Reader function
void *reader(void *arg) {
    int id = *(int*)arg;
    int attempts = 0;

    while (attempts < MAX_ATTEMPTS) {
        // Entry section
        sem_wait(&mutex);
        num_readers++;
        if (num_readers == 1) {
            sem_wait(&wrt);
        }
        sem_post(&mutex);

        // Critical section
        printf("Reader %d read shared_data as %d\n", id, shared_data);

        // Exit section
        sem_wait(&mutex);
        num_readers--;
        if (num_readers == 0) {
            sem_post(&wrt);
        }
        sem_post(&mutex);

        attempts++;
    }

    pthread_exit(NULL);
}

// Writer function
void *writer(void *arg) {
    int id = *(int*)arg;
    int attempts = 0;

    while (attempts < MAX_ATTEMPTS) {
        // Entry section
        sem_wait(&wrt);

        // Critical section
        shared_data++;
        printf("Writer %d wrote shared_data as %d\n", id, shared_data);

        // Exit section
        sem_post(&wrt);

        attempts++;
    }

    pthread_exit(NULL);
}

int main() {
    // Initialize semaphores
    sem_init(&mutex, 0, 1);
    sem_init(&wrt, 0, 1);

    // Create reader threads
    pthread_t reader_threads[NUM_READERS];
    int reader_ids[NUM_READERS];
    for (int i = 0; i < NUM_READERS; i++) {
        reader_ids[i] = i;
        pthread_create(&reader_threads[i], NULL, reader, &reader_ids[i]);
    }

    // Create writer threads
    pthread_t writer_threads[NUM_WRITERS];
    int writer_ids[NUM_WRITERS];
    for (int i = 0; i < NUM_WRITERS; i++) {
        writer_ids[i] = i;
        pthread_create(&writer_threads[i], NULL, writer, &writer_ids[i]);
    }

    // Wait for threads to finish
    for (int i = 0; i < NUM_READERS; i++) {
        pthread_join(reader_threads[i], NULL);
    }
    for (int i = 0; i < NUM_WRITERS; i++) {
        pthread_join(writer_threads[i], NULL);
    }

    // Destroy semaphores
    sem_destroy(&mutex);
    sem_destroy(&wrt);

    return 0;
}



_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 




# Practical-8th (Inter Process Communication Using Pipes/Shared Memory/RCP)



* Establish Interprocess communication (IPC) between Parent and child process using unnamed pipe.


 Code: 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>


int main() {
	int pipefd[2]; // file descriptors for the pipe
	char buffer[25];
	pid_t pid;

	if (pipe(pipefd) == -1) { // create the pipe
    	printf("Pipe failed\n");
    	return 1;
	}

	pid = fork(); // create a child process

	if (pid < 0) { // fork failed
    	printf("Fork failed\n");
    	return 1;
	}

	if (pid > 0) { // parent process
    	close(pipefd[0]); // close the read end of the pipe
    	printf("Parent process writing to pipe...\n");
    	write(pipefd[1], "Hello, child process!", 22);
    	close(pipefd[1]); // close the write end of the pipe
	}
	else { // child process
    	close(pipefd[1]); // close the write end of the pipe
    	printf("Child process reading from pipe...\n");
    	read(pipefd[0], buffer, 25);
    	printf("Child process received: %s\n", buffer);
    	close(pipefd[0]); // close the read end of the pipe
	}

	return 0;
}


_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _




* Establish Interprocess communication (IPC) between Parent and child process using named pipe.


 Code: 

#include <sys/types.h> 
#include <sys/stat.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main(){

	int pid, fd1, fd2;
	char buffer[20];
	
	mkfifo("my_Pipe", 0666); 
	
	pid=fork();
	if(pid > 0){
		//Parent Section
		fd1=open("my_Pipe", O_WRONLY); 
		write(fd1, "Hello Child Process\n",20);
	}
	if(pid==0){
		//Child section
		fd2=open("my_Pipe", O_RDONLY);
		read(fd2, buffer, 20);
		printf("%s", buffer);
	}
	
	return 0;
}

FIND SIZE OF EACH FILE IN A DIRECTORY *************

#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>

int main() {
    DIR *d;
    struct dirent *entry;
    struct stat file_info;

    // Open the directory
    d = opendir("etp");

    // Check if directory opening was successful
    if (d != NULL) {
        printf("Printing contents of etp directory:\n");

        // Read directory entries
        while ((entry = readdir(d)) != NULL) {
            // Construct the file path
            char file_path[1024];
            snprintf(file_path, sizeof(file_path), "etp/%s", entry->d_name);

            // Get file info
            if (stat(file_path, &file_info) == 0) {
                printf("%s - %ld bytes\n", entry->d_name, (long)file_info.st_size);
            } else {
                printf("Error getting info for %s\n", entry->d_name);
            }
        }

        // Close the directory
        closedir(d);
    } else {
        // Print an error message if the directory couldn't be opened
        perror("Unable to open directory");
        return 1; // Exit with error status
    }

    return 0; // Exit normally
}

-->
